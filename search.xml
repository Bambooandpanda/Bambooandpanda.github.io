<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++数组形参]]></title>
    <url>%2F2019%2F03%2F24%2FpostC-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82%2F</url>
    <content type="text"><![CDATA[因为数组会被转换为指针，所以当我们为函数传递一个数组的时候，实际上传递的是指向数组首元素的指针 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式 1void print(const int*);void print(const int[]);//可以看出来，函数的意图是作用于一个数组void print(const int[10]);//这里的维度表示 我们期望 数组中含有多少元素，实际不一定！ 使用标记指定数组长度适合有明显结束标记并且该标记不会与普通数据混淆的情况，例如字符数组，但是对于例如int类型的数组就不太有效了 使用标准库规范begin()和end()传递数组首元素和尾后元素的指针 1void print(const int *beg, const int *end)&#123; while(beg!=end)&#123; cout&lt;&lt;*beg++&lt;&lt;endl; &#125;&#125; 数组形参和const当函数不需要对数组元素执行写操作的时候，数组形参应当是指向const的指针。只有当函数确实需要改变元素值的时候，才把形参定义成指向非常量的指针。 （注意：数组会被转换为指针，当我们为函数传递一个数组的时候，实际上传递的是指向数组首元素的指针） 数组引用类型注意数组的引用形式！ 1void print(int (&amp;arr)[10])&#123; for(auto elem : arr) cout&lt;&lt;elem&lt;&lt;endl;&#125; 传递多维数组C++中实际上没有真正的多维数组，所谓的多维数组就是数组的数组]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型算法——再探迭代器]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[插入迭代器插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。 插入迭代器操作 it=t 在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插入迭代器种类的不同，此赋值会分别调用c.push_back(t) c.push_front(t) c.inserter(t,p)，其中p为传递给inserter的迭代器位置 *t ++t t++ 这些操作虽然存在，但是不会对it做任何事情，返回值是it 只有在容器支持push_back的情况下，我们才能使用back_inserter，front_inserter同理 front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter的时候，元素总是 插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了。 123456list &lt;int&gt; lst=&#123;1,2,3,4&#125;;list &lt;int&gt; lst2,lst3;//拷贝完成之后，lst2包含4321copy(lst.cbegin(),lst.cend(),front_inserter(lst2));//拷贝完成之后，lst3包含1234copy(lst.cbegin(),lst.cend(),inserter(lst3,lst3.begin())); iostream迭代器istream_iterator操作当创建一个流迭代器的时，必须制定迭代器要读写的对象类型。一个istream_iterator使用&gt;&gt;来读取流。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器。 1234istream_iterator&lt;int&gt; int_it(cin);//从cin读取intistream_iteratro&lt;int&gt; int_eof;//默认初始化，创建了一个可以当做尾后值使用的迭代器ifstream in("afile");istream_iterator&lt;string&gt; str_it(in);//从"afile"读取文件字符串 istream_iterator in(is) in从输入流is读取的类型为T的值 istream_iterator end; 读取类型为T值得istream_iterator迭代器，表示尾后位置 in1==in2 in1和in2必须读取相同类型。如果它们都是尾后迭代器或者绑定到相同的输入，那么二者相同 in1!=in2; *in 返回从流中读取的值 in-&gt;men 与(*in).men的含义相同 ++in,in++ 使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 istream_iterator允许使用懒惰求值当我们将一个istream_iterator绑定到一个流的时候，标准库并不保证迭代器立即从流中读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器的时候才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。 ostream_iterator操作在创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个c风格字符串。必须将ostream_iterator绑定到一个指定的流，不允许空的或者表示尾后位置的ostream_iterator。 ostream_iterator out(os) out将类型为T的值写到输出流中 ostream_iterator out(os,d) out将类型为T的值写到输出流OS中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组。 out=val; 用&lt;&lt;运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容 *out,++out,out++ 这些运算符是存在的，但是不对out做任何事情。每个运算符都返回out 1234ostream_iterator &lt;int&gt; out_iter(cout," ");for(auto a:vec) *out_iter++=e;//赋值语句实际上将每个元素都写到coutcout&lt;&lt;endl; 值得注意的是，当我们向out_iter赋值的时候，可以忽略解引用和递增运算 反向迭代器 reverse_iterator反向迭代器就是在容器中从尾元素到首元素反向移动的迭代器。对于反向迭代器，递增的操作含义会颠倒过来。 注意crend(),rend(),crbegin(),rbegin()等]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四周计划与总结]]></title>
    <url>%2F2019%2F03%2F18%2F%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%A1%E5%88%92%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第四周计划C++泛型算法 定制操作 再探迭代器 泛型算法结构 特定容器算法 拷贝控制 拷贝、赋值与销毁 拷贝控制和资源管理 离散数学离散数学及其应用 命题逻辑 命题逻辑的应用 命题等价式 谓词和量词 嵌套量词 推理规则 证明导论 证明的方法和策略 高等数学 8.3 8.4 9.3 9.4 9.5 9.6 9.7 英语六级 Word List 1 Word List 2 Word List 3 Word List 4 Word List 5 Word List 6 Word List 7 Word List 8 Word List 9 Word List 10 Word List 11 Word List 12 Word List 13 总结与反思 要结合原版书籍进行阅读。这周在看《离散数学及其应用》的时候，一直卡在“蕴含”中的p仅当q。最后查阅相关网页才发现原来是译者在翻译的时候翻译错了。看来以后阅读专著需要结合英文原版书籍进行阅读了。长记性了 这周的睡眠情况有所好转，也没有感觉压力那么大了。每天都给自己留出来了放松的时间。（每天都有放空的时间，要控制好啊）感觉这一周没有干什么事。又感觉自己好忙。看来要在这周日之前完成所有没完成的任务，从下周开始重新做人了Emmm。我一定要在11点30之前上床睡觉 这周见到了小导师。导师定了一个小目标“ACM”全国性质的奖（还有啥来着？！）。从下一周开始00就要学习新的课程了（数据结构和算法）。希望自己能在这学期结束之前看完。还有MySQL和Java。导师还强调了“边做边学”，还要提高自学能力。 作业一定要每节课下课以后立马做。不要拖到第二天，要不我准得忘。上课不能总是想着下课了。已经第四周了，还没有踏实下来。 这周自习情况。基本这一周没有怎么去上自习。下一周需要拉着小组成员去自习了。]]></content>
      <tags>
        <tag>大一下计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型算法——定制操作]]></title>
    <url>%2F2019%2F03%2F18%2Fpost%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[泛型算法——定制操作谓词谓词是一个可以调用的表达式，其返回的结果是一个能用作条件的值。 谓词分为一元谓词和二元谓词。 lambda表达式根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格地接受一个或者两个参数。当需要传递多个值的时候，可以考虑用lambda表达式 我们可以向一个算法传递任何类别的可调用对象。对于一个对象或者一个表达式，如果可以对其使用调用运算符，则称它为可调用的。 我们可以将lambda表达式理解为一个未命名的内联函数，与任何函数类似，一个lambda表达式具有一个返回类型，一个参数列表和一个函数体，与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式 1[capture list](parameter list)-&gt;return type&#123;function body&#125; 捕获列表是一个lambda所在函数中定义的局部变量的列表，通常为空。与普通函数不同的是，lambda必须使用尾置返回来指定返回类型。 我们可以忽略参数列表和返回类型，但是必须永远包含捕获列表和函数体 1auto f=[]&#123;return 42&#125;; 此例中，我们定义了一个可调用对象f，它不接受参数，返回42. lambda的调用方式和普通函数的调用方式相同，都是使用调用运算符。 1cout&lt;&lt;f()&lt;&lt;endl;//Output 42 如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体只是一个return语句，那么返回类型从返回的表达式的类型推断而来，否则，返回类型是void。如果函数体包含任何单一return语句之外的内容，并且未指定返回类型，则返回void。 向lambda传递参数调用一个lambda时给定的实参用来初始化lambda的形参。但是，lambda不能有默认参数。空捕获列表表示此lambda不使用它所在的函数中任何的局部变量。 使用捕获列表虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中，来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需要的信息。 lambda以一对[ ]开始，我们可以在其中提供一个逗号分隔名字列表，这些名字都是它所在函数中定义的。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量 lambda捕获和返回当我们定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。目前，可以这样理解，当一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个lambda初始化的变量时，定义了一个从lambda生成的类型的对象。 值捕获类似于参数传递，变量的捕获方式也可以是值或者引用。我们的lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值在lambda创建时拷贝，而不是调用时拷贝。 123456void fcn2()&#123; size_t v1=42; auto f2=[v1]&#123;return v1;&#125;; v1=0; auto j=f2();&#125; 引用捕获需要注意的是，如果我们采用引用方式捕获一个变量，就需要确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。 123456void fcn2()&#123; size_t v1=42; auto f2=[&amp;v1]&#123;return v1;&#125;; v1=0; auto j=f2();&#125; 隐式捕获除了显示列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来腿短我们要使用的变量。为了指示编译器推断捕获列表，应在捕获列表中写一个=或者&amp;。=表示值捕获，&amp;表示引用捕获。 如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获 12[&amp;,c]//c显式捕获，值捕获方式，其他隐式捕获，引用方式[=,c]//c显式捕获，引用捕获方式，其他隐式捕获，值捕获方式 lambda捕获列表总结 空捕获列表 [names]names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量，默认情况下使用值捕获，如果名字前面加上了&amp;，就采用引用捕获 [&amp;]隐式捕获列表，采用引用捕获方式 [=]隐式捕获列表，采用值捕获方式 [&amp;,其他变量使用值捕获] [=,其他变量使用引用捕获] 可变lambda默认情况下，对于一个值被拷贝的变量（值捕获），lambda不会改变其值，（引用捕获是否可以修改取决于引用指向的是一个const还是一个非const ）。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表 123456void fcn3()&#123; size_t v1=42; auto f2=[v1]()mutable&#123;return v1;&#125;; v1=0; auto j=f2();&#125; 指定lambda返回类型参数绑定对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应当定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要许多语句才能完成，通常使用函数最好。如果lambda表达式的捕获列表为空，通常可以用函数来实现它。 标准库bind函数bind函数定义在头文件functional中，可以将函数bind看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表 调用bind的一般形式为 1auto newCallable=bind(callable,arg_list); 其中，newCallable本身是一个可以调用的对象，arg_list是一个逗号分隔符的参数列表，对应给定的参数Callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list的参数 一个简单的例子123//check6是一个可调用对象，接受一个string类型的参数//并用此string和值6来调用check_sizeauto check6=bind(check_size,_1,6); 此bind调用只有一个占位符，表示check只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。这个参数是const string&amp;。 12string s="Hello";bool b1=check6(s);//check6(s)会调用check_size(s,6) bind生成一个可调用对象，将占位符的变量绑定到对应位置。 使用placeholders名字名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间中。为了使用这些名字，两个命名空间都要写上。 1using namespace namespace_name; bind的参数1auto g=bind(f,a,b,_2,c,_1); 生成了一个新的可调用对象，他有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将自己的参数最为第三个和第五个参数传递给f。f的第一个第二个和第四个参数分别被绑定到给定值a.b.c上。 用bind排参数顺序1234//按照单词长度由短至长排列sort(words.begin(),words.end(),isShorter);//按照单词长度由长至短排列sort(words.begin(),words.end(),bind(isShorter,_2,_1)); 绑定引用参数默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是与lambda表达式相似，有事对一些绑定的参数我们希望以引用方式传递，或者是要绑定参数的类型无法拷贝。这时，我们必须使用标准库ref()函数。 1for_each(words.begin().words.end(),bind(print,ref(os),_1,' '));]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三周计划与总结]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%A1%E5%88%92%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[英语六级 Word List 9 Word List 10 Word List 11 Word List 12 Word List 13 C++ 回顾类、IO库、顺序容器 泛型算法 关联容器 动态内存 拷贝复制 重载运算符与类型转换 理解函数对象 lambda表达式 STL算法 Essential C++ 离散数学及其应用 离散数学及其应用第一章 高等数学 9.1 9.2 9.3 9.4 9.5 MatLab 台大课程1 台大课程2 台大课程3 台大课程4 台大课程5 台大课程6 台大课程7 总结与反思 这一周的任务明显比较多。加之创新创业大赛的准备，压力实在是大。睡眠时间和睡眠质量有所下降。看来需要熄灯就躺在床上了。 C++感到了卡壳。看来不能囫囵吞枣。要多写代码多实践。下一周再回顾之前的内容叭。 虽然定了好多目标，但是没有完成多少，反而给自己带来了不小压力。状态急剧下降。看来下一周制定计划要按照实际了。 调整心态。平常听歌不能听躁的了，不然更没办法学习了。近期先听一些舒缓的吧。 还是感觉大学物理好难啊！ 我是真的明白了“欲速则不达”。]]></content>
      <tags>
        <tag>大一下计划与总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型算法]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[泛型算法概述泛型算法之所以被称为是“泛型算法”是因为它们可以被用于不同类型的元素和多种容器类型（不仅包括标准库类型，比如vector或list，还包括内置的数组类型） 大多数算法都被定义在头文件algorithm中，标准库头文件numeric中定义了一组数值泛型算法 初识泛型算法除了少数例外，标准库算法都对一个范围内的元素进行操作，我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器 只读算法只读取输入范围内的元素，而从不改变其元素 迭代器参数一些算法从两个序列中读取元素。构成这两个序列的元素可以来自不同类型的容器。例如，第一个序列可能保存于一个vector中，第二个序列可能保存于一个list、deque、内置数组或其他容器中。而且两个序列中的元素类型不要求严格匹配 用一个单一迭代器表示第二个序列的算法都假定第二个序列至少于第一个一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任 算法不检查写操作需要注意的是，向目的位置迭代器写入数据的算法假定目的位置足够大，能够容纳写入的元素 一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或者类似的写元素的写法） 123vector &lt;int&gt; vec;//空向量//灾难：修改vec中的10个（不存在的元素）fill_n(vec.begin(),10,0); back_inserter插入迭代器一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过次迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。 123vector &lt;int&gt; vec;//空向量auto it=back_inserter(vec);//通过it赋值会将元素添加到vec中*it=42；//vev中现在有一个元素，值为42 通过使用back_inserter插入迭代器，就可以尽量减少因“算法不检查写操作”而产生的错误。 123vector &lt;int&gt; vec;//空向量//正确：back_inserter创建一个迭代器，可以用来向vec添加元素fill_n(back_inserter(vec),10,0);//添加10个元素到vec中 拷贝算法需要注意的是，传递给copy的目的序列至少要包含与输入序列一样多的元素，这点很重要。 replace算法：读入一个序列，并将其中所有等于给定值的元素都改为另一个值 replace_copy算法：读入一个序列，将其中所有给定的值都改为另一个值，并储存在另一序列中，原序列保持不变。 重排元素的算法sort()可以将相邻相消除的算法unique()需要注意的是，unique并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，unique返回的迭代器只想最后一个不重复元素之后的位置。 使用容器操作删除元素erase()erase(it); erase(it.begin(),it.end()); 定制操作]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前置++和后置++的区别]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%89%8D%E7%BD%AE-%E5%92%8C%E5%90%8E%E7%BD%AE-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前置++和后置++的区别int a = 0;++ a; //前置++a++; //后置++ 《C专家编程》中有如下描述（P276，人民邮电出版社）： ++a表示取a的地址，增加它的内容，然后把值放在寄存器中； a++表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值； 另外，网上找了篇文章，通过从运算符重载的角度来探讨他们的不同，如下： 假设有一个类Age，描述年龄。该类重载了前置++和后置++两个操作符，以实现对年龄的自增。 class Age { public: Age&amp; operator++() //前置++ { ++i; return *this; } const Age operator++(int) //后置++ { Age tmp = *this; ++(*this); //利用前置++ return tmp; } Age&amp; operator=(int i) //赋值操作 { this-&gt;i = i; return *this; } private: int i; }; 从上述代码，我们可以看出前置++和后置++，有几点不同： 返回类型不同 形参不同 代码不同 效率不同 返回值类型的区别 前置++的返回类型是Age&amp;，后置++的返回类型const Age。这意味着，前置++返回的是左值，后置++返回的是右值。 左值和右值，决定了前置++和后置++的用法。 int main() { Age a; (a++)++; //编译错误 ++(a++); //编译错误 a++ = 1; //编译错误 (++a)++; //OK ++(++a); //OK ++a = 1; //OK } ++的类型是const Age，自然不能对它进行前置++、后置++、赋值等操作。 ++a的类型是Age&amp;，当然可以对它进行前置++、后置++、赋值等操作 Q :a++的返回类型为什么要是const对象呢？有两个原因： 如果不是const对象，a(++)++这样的表达式就可以通过编译。但是，其效果却违反了我们的直觉 。a其实只增加了1，因为第二次自增作用在一个临时对象上。 另外，对于内置类型，(i++)++这样的表达式是不能通过编译的。自定义类型的操作符重载，应该与内置类型保持行为一致 。a++的返回类型如果改成非const对象，肯定能通过编译，但是我们最好不要这样做。 Q :++a的返回类型为什么是引用呢？这样做的原因应该就是：与内置类型的行为保持一致。前置++返回的总是被自增的对象本身。因此，++(++a)的效果就是a被自增两次。 形参的区别前置++没有形参，而后置++有一个int形参，但是该形参也没有被用到。很奇怪，难道有什么特殊的用意？ 其实也没有特殊的用意，只是为了绕过语法的限制。 前置++与后置++的操作符重载函数，函数原型必须不同。否则就违反了“重载函数必须拥有不同的函数原型”的语法规定。 虽然前置++与后置++的返回类型不同，但是返回类型不属于函数原型。为了绕过语法限制，只好给后置++增加了一个int形参。 原因就是这么简单，真的没其他特殊用意。其实，给前置++增加形参也可以；增加一个double形参而不是int形参，也可以。只是，当时就这么决定了。 代码实现的区别前置++的实现比较简单，自增之后，将*this返回即可。需要注意的是，一定要返回*this。 后置++的实现稍微麻烦一些。因为要返回自增之前的对象，所以先将对象拷贝一份，再进行自增，最后返回那个拷贝。 在Age的代码中，后置++利用了前置++来实现自增。这样做是为了避免“自增的代码”重复。 在本例中，自增的代码很简单，就是一行++i，没有必要这样做。但是在其它自增逻辑复杂的例子中，这么做还是很有必要的。 效率的区别如果不需要返回自增之前的值，那么前置++和后置++的计算效果都一样。但是，我们仍然应该优先使用前置++，尤其是对于用户自定义类型的自增操作。 前置++的效率更高，理由是：后置++会生成临时对象。 从Age的后置++的代码实现也可以看出这一点。 123456const Age operator++(int) //后置++ &#123; Age tmp = *this; ++(*this); //利用前置++ return tmp; &#125; 很明显，tmp是一个临时对象，会造成一次构造函数和一次析构函数的额外开销。虽然，编译器在某些情况下可以优化掉这些开销。但是，我们最好不要依赖编译器的行为。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符重载]]></title>
    <url>%2F2019%2F03%2F10%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[单目运算符作为类成员的（非静态函数）的单目运算符没有参数，因为它们使用的唯一的参数是当前实例（*this），如下所示： 123return_type operator operator_type()&#123; ///...implementation&#125; 单目递增运算符和单目递减运算符前置形式 1234A&amp; operator ++()&#123; //operator implementation code return *this;&#125; 后置形式 12345678A operator ++(int)&#123; //Store a copy of the current state of the object, before incrementing A copy(*this); //increment implementation code //一般我们可以写++A;从而利用之前定义声明过的前置形式 //return state before increment return copy;&#125; 后置单目运算符函数需要一个不参与运算的整型形参，用作重载识别，操作数是类对象const Clock operator++(int) //后置++，返回操作数的局部变量的常副本（此处的int是一个哑元，，哑元就是只有类型没有名称的参数，它用来区别不同的函数，比如这里的前++和后++。） Q:为什么前++函数的返回值是一个引用，后++函数返回的是一个constA：在规则上，前++是可以连续使用（单目递增运算符的结合性时从右到左，所以前置++可以连续使用），当我们只是一次++时，是要返回一个值的，既然能够使用，所以这个值我们是可以拿过来修改的，同理，既然后++不能连用，这就意味着其返回值是不能修改的。 转换运算符若有类A，运行如下代码 12A a;cout&lt;&lt;a; 编译器会报错，因为cout不知道如何解读A实例，因为A类不支持这样的运算符，即将A对象的内容转换成cout能够接受的类型。 然而，要让cout能够很好地显示const char* 1std::cout&lt;&lt;"Hello world"; 因此，要让cout能够显示A对象，只需要添加一个返回const char*的运算符 123operator const char*()&#123; //operator implementation that returns a char*&#125; 实例代码： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;class Date &#123;private: int day, month, year; string dateInString;public: Date(int inMonth, int inDay, int inYear) :month(inMonth), day(inDay), year(inYear) &#123;&#125;; operator const char* () &#123; ostringstream formattedDate; formattedDate &lt;&lt; month &lt;&lt; "/" &lt;&lt; day &lt;&lt; "/" &lt;&lt; year; dateInString = formattedDate.str(); return dateInString.c_str(); &#125;&#125;;int main() &#123; Date Holiday(12, 25, 2016); cout &lt;&lt; "Holiday is on" &lt;&lt; Holiday &lt;&lt; endl; return 0;&#125; 注意这样的赋值将导致隐式转换，即为了让复制通过编译而不引发错误，编译器使用了可用的转换运算符（这里是const char*），为了禁止隐式转换，可以再运算符声明开头使用关键字explicit，如下所示 123explicit operator const char*()&#123; //conversion code here&#125; 通过使用关键字explicit，可以要求程序员使用强制类型装换来确认转换意图 12string strHoliday(static_cast&lt;const char*&gt;(Holiday));strHoliday=static_cast&lt;const char*&gt;(Date(11,11,2016)); 应当根据类的可能用法编写尽可能多的运算符，如果应用程序需要Date对象的整数表示，可编写如下运算符 123explicit operator int()&#123; return day+month+year;&#125; 这样便可以将Date对象当做整数来使用 1FuncTakesInt(static_cast&lt;int&gt;(Date(12,25,2016))) 解除引用运算符（*）和成员选择运算符（-&gt;）二者在智能指针编程中应用最广。示例程序如下： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Date &#123;private: int day, month, year; string dateInString;public: Date(int inMonth, int inDay, int inYear) :month(inMonth), day(inDay), year(inYear) &#123;&#125;; void DisplayDate() &#123; cout &lt;&lt; month &lt;&lt; "/" &lt;&lt; day &lt;&lt; "/" &lt;&lt; year &lt;&lt; endl; &#125;&#125;;int main() &#123; unique_ptr&lt;int&gt; smartIntPtr(new int); *smartIntPtr = 42; //Use smart pointer type like an int* cout &lt;&lt; "Integer value is " &lt;&lt; *smartIntPtr &lt;&lt; endl; unique_ptr&lt;Date&gt; smartHoliday(new Date(12, 25, 2016)); cout &lt;&lt; "The new instance of date contains"; //use smartHoliday just as you would a Date smartHoliday-&gt;DisplayDate(); return 0;&#125; 具体情况将在智能指针进行讨论 双目运算符以全局函数或者静态成员函数的方式实现的双目运算符的定义如下： 1return_type operator_type (parameter1,parameter2); 以类成员的方式实现的双目运算符的定义如下： 1return_type operator_type (parameter); 以类成员的方式实现的双目运算符只接收一个参数，其原因是第二个参数通常是从类属性获得的。 双目加法和双目减法运算符实例代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Date &#123;private: int day, month, year; string dateInString;public: Date(int inMonth, int inDay, int inYear) :month(inMonth), day(inDay), year(inYear) &#123;&#125;; Date operator + (int daysToAdd) &#123; Date newDate(month, day + daysToAdd, year); return newDate; &#125; Date operator - (int dayToSub) &#123; return Date(month, day - dayToSub, year); &#125; void Display() &#123; cout &lt;&lt; month &lt;&lt; "/" &lt;&lt; day &lt;&lt; "/" &lt;&lt; year &lt;&lt; endl; &#125;&#125;;int main() &#123; Date Holiday(12, 25, 2016); cout &lt;&lt; "Holiday on " &lt;&lt; endl; Holiday.Display(); Date PreviousHoliday(Holiday - 19); cout &lt;&lt; "Previous holiday on "; PreviousHoliday.Display(); Date NextHoliday(Holiday + 6); cout &lt;&lt; "Next holiday on:"; NextHoliday.Display();&#125; op=运算符重载1234567891011121314151617181920212223242526class Date &#123;private: int day, month, year; string dateInString;public: Date(int inMonth, int inDay, int inYear) :month(inMonth), day(inDay), year(inYear) &#123;&#125;; Date operator + (int daysToAdd) &#123; Date newDate(month, day + daysToAdd, year); return newDate; &#125; Date operator - (int dayToSub) &#123; return Date(month, day - dayToSub, year); &#125; void Display() &#123; cout &lt;&lt; month &lt;&lt; "/" &lt;&lt; day &lt;&lt; "/" &lt;&lt; year &lt;&lt; endl; &#125; void operator+=(int DayToAdd)&#123; day=+DayToAdd; &#125; //and so on &#125;; ==运算符和!=运算符重载等于运算符的通用实现如下 123bool operator == (const ClassType&amp; compareTo)&#123; //comparison code here, return true if equal else here&#125; 实现不等运算符时，可重用等于运算符 123bool operator != (const ClassType&amp; compareTo)&#123; //comparision code here, return true if equal else false&#125; 实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;class Date &#123;private: int day, month, year;public: Date(int inMonth, int inDay, int inYear) :month(inMonth),day(inDay),year(inYear)&#123;&#125; bool operator == (const Date&amp; compareTo) &#123; return ((day == compareTo.day) &amp;&amp; (month == compareTo.month) &amp;&amp; (year == compareTo.year)); &#125; bool operator != (const Date&amp; compareTo) &#123; return !(this-&gt;operator==(compareTo)); &#125; void DispalyDate() &#123; cout &lt;&lt; month &lt;&lt; "/" &lt;&lt; day &lt;&lt; "/" &lt;&lt; year &lt;&lt; endl; &#125;&#125;;int main() &#123; Date holiday1(12, 25, 2016); Date holiday2(12, 31, 2016); cout &lt;&lt; "holiday 1 is "; holiday1.DispalyDate(); cout &lt;&lt; "holiday 2 is "; holiday2.DispalyDate(); if (holiday1 == holiday2) cout &lt;&lt; "Equality operator: The two are on the same day" &lt;&lt; endl; else cout &lt;&lt; "Equality operator: The two are on different days" &lt;&lt; endl; if (holiday1 != holiday2) cout &lt;&lt; "Inequality operator: The two are on different days" &lt;&lt; endl; else cout &lt;&lt; "Inequality operator: The two are on the same day" &lt;&lt; endl; return 0;&#125; 注意123bool operator != (const Date&amp; compareTo) &#123; return !(this-&gt;operator==(compareTo));&#125; 在这条return语句中，this-&gt;operator==()，其实相当于调用了bool operator == (const Date&amp; compareTo)，根据函数和地址的关系。（C++Primer： 当我们把函数名作为一个值使用的时，该函数自动的转化成指针） 重载复制赋值运算符有时候，需要将一个类实例的内容赋给另一个类实例，如下所示 123Date holiday(12,25,2016);Date anotherHoliday(1,1,2017);anotherHoliday=holiday; 如果您没有提供复制赋值运算符，这将调用编译器自动给类添加的默认复制赋值运算符（浅复制）。为了确保进行深复制，您需要提供复制赋值运算符。 下标运算符下标运算符让您能够像访问数组那样访问类，典型语法如下 1return_type &amp; operator [] (subscript_type &amp; subscript); 示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string.h&gt;using namespace std;class MyString &#123;private: char* buffer; //private default constructor MyString()&#123;&#125;public: //constructor MyString(const char* initialInput) &#123; if (initialInput != NULL) &#123; buffer = new char(strlen(initialInput) + 1); strcpy(buffer, initialInput); &#125; else buffer = NULL; &#125; //copy constructor MyString(const MyString&amp; copySource); MyString&amp; operator =(const MyString&amp; copySource); const char&amp; operator [](int index) const &#123; if (index &lt; GetLength()) return buffer[index]; &#125; //Destructor ~MyString() &#123; if (buffer != NULL) delete[]buffer; &#125; int GetLength()const &#123; return strlen(buffer); &#125; operator const char* () &#123; return buffer; &#125;&#125;;int main() &#123; cout &lt;&lt; "Type a statement:"; string strInput; getline(cin, strInput); MyString youSaid(strInput.c_str()); cout &lt;&lt; "Using operator[] for displaying your input" &lt;&lt; endl; for (int index = 0; index &lt; youSaid.GetLength(); ++index) cout &lt;&lt; youSaid[index] &lt;&lt; " "; cout &lt;&lt; endl; cout &lt;&lt; "Enter index 0 - " &lt;&lt; youSaid.GetLength() - 1 &lt;&lt; ":"; int index = 0; cout &lt;&lt; "Input character at zero-based position" &lt;&lt; index; cout &lt;&lt; " is:" &lt;&lt; youSaid[index] &lt;&lt; endl; return 0;&#125; 函数运算符operator()operator()让对象更象函数，被称为函数运算符。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Display &#123;public: void operator ()(string input) const &#123; cout &lt;&lt; input &lt;&lt; endl; &#125;&#125;;int main() &#123; Display displayFuncObj; //equivalent to displayFuncObj.operator()("Display this string"); displayFuncObj("Dispaly this string"); return 0;&#125; 注意到之所以能够将对象displayFuncObj用作函数，是因为编译器隐式地将它转化为对函数operator()的调用 用户定义的字面量要定义字面量，可以像下面这样定义operator”” 123Return_type operator "" YourLiteral(ValueType value)&#123; //conversion code here&#125; 示例程序如下： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;struct Temperature &#123; double Kelvin; Temperature(long double kelvin):Kelvin(kelvin)&#123;&#125;&#125;;Temperature operator"" _C(long double celcius) &#123; return Temperature(celcius + 273);&#125;Temperature operator"" _F(long double fahrenheit) &#123; return Temperature((fahrenheit + 459.67) * 5 / 9);&#125;int main() &#123; Temperature k1 = 31.73_F; Temperature k2 = 0.0_C; cout &lt;&lt; "k1 is " &lt;&lt; k1.Kelvin &lt;&lt; " Kelvin" &lt;&lt; endl; cout &lt;&lt; "k2 is " &lt;&lt; k2.Kelvin &lt;&lt; " Kelvin" &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-使用构造函数进行类型转换]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[请看下面的Human类，它包含一个将整数作为参数的重载构造函数 1234567891011class Human&#123; int age;public: Human(int humansAge):age(humansAge)&#123;&#125;&#125;;//Function that takes a Human as a parametervoid DoSomething(Human person)&#123; cout&lt;&lt;"Human sent did something"&lt;&lt;endl; return;&#125; 这个构造函数让您执行下面的转换 12Humain kid(10);//convert integer in to a HumanDoSomething(kid); 警告这样的转换构造函数能够让您执行隐式转换： 12Human anotherKid=11;DoSomething(10);//10 convert to a Human! 函数DoSomething(Human person)被声明为接受一个Human（而不是int）参数！前面的代码为何可行呢？这是因为编译器知道Human类包含一个将整数作为参数的构造函数，进而替您执行了隐式转换：**将您提供的整数作为参数发送给这个构造函数，从而创建一个Human对象。 为了避免隐式转换，可以在声明构造函数的时候使用关键字explict 12345class Human&#123; int age; public: explicit Human(int humansAge):age(humansAge)&#123;&#125;&#125;; 并非必须使用关键字explicit，但是在很多情况下，这都是一种良好的编程实践。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-只能有一个实例的单例类]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[不允许复制的类 中讨论的President类很不错，但是有一个缺陷：无法禁止通过实例化多个对象来创建多名总统。 由于复制构造是私有的，其中的每个对象都是不可复制的，但是您的目标是确保President类有且仅有一个化身，即有了一个President对象以后，就禁止创建其他的President对象。要实现这种功能强大的模式，可以使用单例类的概念，它使用私有的构造函数，私有赋值运算符和静态实例成员。 要创建单例类，关键字static必不可少。 关键字static static用于类的数据成员时，该数据成员将在所有的实例之间共享 static用于函数中声明的局部变量时，该变量的值将在两次调用之间保持不变 static用于成员函数（方法）时，该方法在所有成员之间进行共享 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class President &#123;private: President() &#123;&#125;;//private default constructor President(const President&amp;);//private copy constructor const President&amp; operator = (const President&amp;);//assignment operator string name;public: static President&amp; GetInstance() &#123; //static objects are constructed only once static President onlyInstance;//onlyPresident是一个局部变量，这样在以后调用这个函数的时候，返回的都是onlyInstance这个实例。 return onlyInstance; &#125; string GetName() &#123; return name; &#125; void SetName(string InputName) &#123; name = InputName; &#125;&#125;;int main() &#123; President&amp; onlyPresident = President::GetInstance(); onlyPresident.SetName("Abraham Lincoln"); //uncomment lines to see how compile failures prohibit duplicates //President second;//cannot access constructor //President * third=new President();//cannot access constructor //President fourth=onlyPresident;//cannot access copy constructor //onlyPresident=President::GetInstance();//connot access operator = cout &lt;&lt; "The name of the President is:"; cout &lt;&lt; President::GetInstance().GetName() &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-不允许复制的类]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E4%B8%8D%E5%85%81%E8%AE%B8%E5%A4%8D%E5%88%B6%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[假设您需要模拟国家的整体。一个国家只能有一位总统，而president类面临如下风险： 1234Presient ourPresident;DoSomething(ourPresident);//duplicate created in passing by valuePresident clone;clone = ourpresident;//duplicate via assignment 显然，需要避免这样的情况发生。 如果您不生命复制构造函数，C++将为您添加一个公有的默认复制构造函数，这破坏了您的设计，威胁着您的实现。然而，C++提供了这种设计范式的解决方案。 要禁止类对象被复制，可以声明一个私有的复制构造函数。这确保函数调用DoSomething(ourPresident)无法通过编译。为禁止赋值，可以声明一个私有的赋值运算符。 1234567class President&#123; private: President(const President&amp;);//private copy constructor President&amp; operator =(const President&amp;);//private copy assignment operator //...other attributes&#125; 无需给私有复制构造函数和私有赋值运算符提供实现，只需将它们声明为私有的就足够实现不允许复制的目标。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-有助于改善性能的移动构造函数]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[如果指针所指向非常大的内存数据的话,则拷贝构造的代价就非常昂贵,会极大地影响性能。C++11提供一种简洁解决方法:移动构造函数,即是在用原对象指针对新对象指针进行赋值后,将原对象成员指针置为空指针,使得其无法指向内存数据,从而保证在析构的时候不会产生内存泄漏。这样既不用分配新内存,也不会产生内存泄漏,从而很好地解决了上述问题。 由于C++的特征和需求，有些情况下对象会自动被复制。请看如下代码 1234567891011121314151617class MyString&#123; //...members&#125;MyString Copy(MyString&amp; source)//function&#123; MyString copyForReturn(source.GetString());//create copy return copyForReturn;&#125;int main()&#123; MyString sayHello("Hello World of C++"); MyString sayHelloAgain(Copy(sayHello));//invokes 2x copy constructor //一次是弄临时变量 return 0;&#125; 正如注释指出的，实例化sayHelloAgain时，由于调用了函数Copy(sayHello)，而它按值返回一个MyString，因此调用了复制构造函数两次。然而，这个返回值存在时间很短，而且在表达式外不可用，因此，C++编译器严格地调用复制构造函数反而降低了性能，如果复制的对象很大，对性能的影响将很严重。 为了避免这种性能瓶颈，C++11引入了移动构造函数。移动构造函数的语法如下： 1234567//move constructorMyString(MyString&amp; moveSource)&#123; if(moveSource.buffer!=NULL)&#123; buffer=moveSource.buffer;//take ownership i.e. 'move' moveSource.buffer=NULL;//set the move source to NULL &#125;&#125; 有移动构造函数的时候，编译器将自动使用它来“移动”临时资源，从而避免深复制。实现移动构造函数后，应将前面的注释改成下面这样： 1MyString sayHelloAgain(Copy(sayHello));//invokes 1x copy, 1x move constructors 移动构造函数通常是利用移动赋值运算符实现的。这将在运算符重载中进行介绍。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟表]]></title>
    <url>%2F2019%2F03%2F10%2F%E8%99%9A%E6%8B%9F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[虚拟表原文链接 为了实现虚函数，C ++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态/后期绑定方式的函数调用函数的查找表。虚拟表有时会使用其他名称，例如“vtable”，“虚函数表”，“虚方法表”或“调度表”。 因为了解虚拟表的工作原理并不需要使用虚函数，所以可以将此部分视为可选读取。 虚拟表实际上非常简单，虽然用文字描述有点复杂。首先，每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的最派生函数。 其次，编译器还会添加一个隐藏指向基类的指针，我们称之为 __ vptr。 vptr在创建类实例时自动设置，以便指向该类的虚拟表。与 this指针不同， this指针实际上是编译器用来解析自引用的函数参数，* vptr是一个真正的指针。因此，它使每个类对象的分配大一个指针的大小。这也意味着* __ vptr由派生类继承，这很重要。 到目前为止，你可能对这些东西如何组合在一起感到困惑，所以让我们来看一个简单的例子： 12345678910111213141516class Base&#123;public: virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;;class D1: public Base&#123;public: virtual void function1() &#123;&#125;;&#125;;class D2: public Base&#123;public: virtual void function2() &#123;&#125;;&#125;; 因为这里有3个类，编译器将设置3个虚拟表：一个用于Base，一个用于D1，一个用于D2。 编译器还会添加一个隐藏指针，指向使用虚函数的最基类。虽然编译器会自动执行此操作，但我们会将其放在下一个示例中，以显示它的添加位置： 1234567891011121314151617class Base&#123;public: FunctionPointer *__vptr; virtual void function1() &#123;&#125;; virtual void function2() &#123;&#125;;&#125;;class D1: public Base&#123;public: virtual void function1() &#123;&#125;;&#125;;class D2: public Base&#123;public: virtual void function2() &#123;&#125;;&#125;; 创建类对象时， *__ vptr设置为指向该类的虚拟表。例如，当创建Base类型的对象时，*vptr设置为指向Base的虚拟表。构造D1或D2类型的对象时，* vptr设置为分别指向D1或D2的虚拟表。 现在，我们来谈谈如何填写这些虚拟表。因为这里只有两个虚函数，每个虚拟表将有两个条目（一个用于function1（），一个用于function2（））。请记住，当填写这些虚拟表时，每个条目都填充了该类类型的对象可以调用的派生最多的函数。 Base对象的虚拟表很简单。Base类型的对象只能访问Base的成员。Base无法访问D1或D2功能。因此，function1的条目指向Base :: function1（），而function2的条目指向Base :: function2（）。 D1的虚拟表稍微复杂一些。D1类型的对象可以访问D1和Base的成员。但是，D1重写了function1（），使得D1 :: function1（）比Base :: function1（）派生得更多。因此，function1的条目指向D1 :: function1（）。D1没有覆盖function2（），因此function2的条目将指向Base :: function2（）。 D2的虚拟表类似于D1，除了function1的条目指向Base :: function1（），而function2的条目指向D2 :: function2（）。 这是图形的图片： 虽然这个图有点疯狂，但它非常简单：每个类中的* __ vptr指向该类的虚拟表。虚拟表中的条目指向允许调用该类的函数对象的最派生版本。 那么考虑当我们创建D1类型的对象时会发生什么： 1int main()&#123; D1 d1;&#125; 因为d1是D1对象，所以d1将其* __ vptr设置为D1虚拟表。 现在，让我们设置一个指向D1的基指针： 1int main()&#123; D1 d1; Base *dPtr = &amp;d1;&#125; 请注意，因为dPtr是基指针，所以它只指向d1的Base部分。但是，请注意* vptr位于类的Base部分，因此dPtr可以访问此指针。最后，请注意dPtr - &gt; vptr指向D1虚拟表！因此，即使dPtr属于Base类型，它仍然可以访问D1的虚拟表（通过__vptr）。 那么当我们尝试调用dPtr-&gt; function1（）时会发生什么？ 首先，程序识别出function1（）是一个虚函数。其次，程序使用dPtr - &gt; __ vptr来获取D1的虚拟表。第三，它查找在D1的虚拟表中调用哪个版本的function1（）。这已设置为D1 :: function1（）。因此，dPtr-&gt; function1（）解析为D1 :: function1（）！ 现在，您可能会说，“但是，如果dPtr真正指向Base对象而不是D1对象，那该怎么办呢？它还会调用D1 :: function1（）吗？“ 答案是不。 1int main()&#123; Base b; Base *bPtr = &amp;b; bPtr-&gt;function1();&#125; 在这种情况下，当创建b时， vptr指向Base的虚拟表，而不是D1的虚拟表。因此，bPtr - &gt; vptr也将指向Base的虚拟表。函数1（）的Base的虚拟表条目指向Base :: function1（）。因此，bPtr-&gt; function1（）解析为Base :: function1（），这是Base对象应该能够调用的function1（）的派生最多的版本。 通过使用这些表，编译器和程序能够确保函数调用解析为适当的虚函数，即使您只使用指针或对基类的引用！ 由于以下几个原因，调用虚函数比调用非虚函数要慢：首先，我们必须使用* __ vptr来获取相应的虚拟表。其次，我们必须索引虚拟表以找到要调用的正确函数。只有这样我们才能调用该函数。因此，我们必须执行3个操作来查找要调用的函数，而不是正常间接函数调用的2个操作，或者直接函数调用的一个操作。然而，对于现代计算机，这个增加的时间通常是相当微不足道的。 另外作为提醒，任何使用虚函数的类都有__vptr，因此该类的每个对象都会被一个指针变大。虚拟功能很强大，但它们确实具有性能成本。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-复制构造函数]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[浅复制及其存在的问题复制某个类的对象时，将复制其指针成员，但不复制指针指向的缓冲区，其结果是两个对象指向同一块动态分配的内存。销毁其中一个对象时，delete[]释放这个内存块，导致另一个对象存储的指针拷贝无效，这种复制被称为浅复制，会威胁程序的稳定性。 使用复制构造函数确保深复制复制构造函数是一个重载的构造函数，由编写类的程序员提供。每当对象被复制时，编译器都将调用复制构造函数。语法如下 123456class A&#123; A(const A&amp; copySource);//copy constructor &#125;;A::A(const A&amp;copySource)&#123; //copy constructor implementation code&#125; 复制构造函数接受一个以引用方式传入的当前类的对象作为参数。这个参数时源对象的别名，您使用它来编写自定义的复制代码，确保对所有的缓冲区进行深复制。 注意复制构造函数确保下面的函数调用进行深复制 12MyString sayHello("Hello from String Class");UseMyString(sayHello); 然而，如果您通过赋值进行复制时，结果如何呢? 12MyString overwrite("who cares?");overwrite=sayHello; 由于您没有提供复制赋值运算符operator=，编译器提供的默认复制赋值运算符将导致浅复制。 赋值运算符将在运算符将在运算符重载中深入讨论。如下实现了复制赋值运算符： 123MyString::operator=(const MyString &amp;copySourse)&#123; //...copy assignment operator code&#125; 除非万不得已，不要将类成员声明为原始指针]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-析构函数]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[与构造函数一样，析构函数是一种特殊的函数。构造函数在实例化对象时被调用，而析构函数在对象销毁时自动被调用。 声明和实现析构函数析构函数看起来像一个与类同名的函数，但前面有一个 ~ 符号。因此，Human类的析构函数的声明类似于下面一样 123class Human&#123; ~Human();&#125;； 在类声明中实现，在类外声明实现的代码形式类似于构造函数在类声明中实现和在类外实现。传送门 何时及如何使用析构函数每当对象不再在作用域内或者通过delete被删除进而被销毁时，都将调用析构函数。这使得析构函数成为重置变量以及释放动态分配的内存和其他资源的理想场所。 1234567891011121314151617181920class MyString &#123;private: char* buffer;public: MyString(const char* initString)//constructor &#123; if (initString != NULL) &#123; buffer = new char[strlen(initString) + 1]; strcpy(buffer, initString); &#125; else buffer = NULL; &#125; ~MyString() &#123; cout &lt;&lt; "Invoking destructor, clearing up" &lt;&lt; endl; if (buffer != NULL) delete[]buffer; &#125;&#125;; 注意析构函数不能重载，每个类都只能有一个析构函数。如果您忘记了实现虚构函数，编译器会创建一个伪析构函数并调用它。伪析构函数为空，即不释放动态分配的内存。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类-构造函数]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[构造函数构造函数是一种特殊的函数（方法），在根据类创建对象时被调用，与函数一样，构造函数也可以重载 声明和实现构造函数构造函数是一种特殊的函数，它与类同名并且不返回任何值。因此，Human类的构造函数的声明类似于下面这样 1234class Human&#123; public: Human();//declaration of a constructor&#125;; 这个构造函数可以从类声明中实现，也可以在类外实现。代码如下： 12345678910111213141516//类内定义class Human&#123; public: Human()&#123; //constructor code here &#125;&#125;;//类外定义class Human&#123; public: Human(); &#125;Human::Human()&#123; //constructor code here&#125; 重载构造函数与函数一样，构造函数也可以重载，因此，可以创建一个将姓名作为参数的构造函数，如下所示： 123456789class Human&#123; public: Human()&#123; //default constructor code here &#125; Human(string humansName)&#123; //overloaded constructor code here &#125;&#125;; 如下程序演示了重载构造函数的用途，它在创建Human对象的时候提供了姓名 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Human &#123;private: string name; int age;public: Human() &#123;//default constructor age = 0;//initialized to ensure no junk value cout &lt;&lt; "Default constructor : name and age not set" &lt;&lt; endl; &#125; Human(string humansName, int humansAge) &#123;//overLoaded name = humansName; age = humansAge; cout &lt;&lt; "Overloaded constructor creats:" &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; " of "&lt;&lt;age &lt;&lt; " years" &lt;&lt; endl; &#125;&#125;;int main() &#123; Human firstMan; Human firstWoman("Eve", 20);&#125; 输出 Default constructor : name and age not setOverloaded constructor creats:Eve of 20 years 如果Human类没有默认构造函数，则在main()中创建每个Human对象时都只能使用将姓名和年龄作为参数的构造函数；在这种情况下，不提供姓名和年龄就无法创建Human对象。 注意您可以选择不实现默认构造函数，从而要求实例化对象时必须提供某些参数。 没有默认构造函数的类在如下程序中，Human没有默认构造函数，因此创建Human对象的时候必须提供姓名和年龄。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Human &#123;private: string name; int age;public: Human(string humansName, int humansAge) &#123;//overLoaded name = humansName; age = humansAge; cout &lt;&lt; "Overloaded constructor creats:" &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; " of " &lt;&lt; age &lt;&lt; " years" &lt;&lt; endl; &#125; void IntroduceSelf() &#123; cout &lt;&lt; "I am " + name &lt;&lt; " and am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;int main() &#123; Human firstMan("Adam", 25); Human firstWoman("Eve", 28); firstMan.IntroduceSelf(); firstWoman.IntroduceSelf();&#125; 输出 Overloaded constructor creats:Adam of 25 yearsOverloaded constructor creats:Eve of 28 yearsI am Adam and am 25 years oldI am Eve and am 28 years old 没有默认构造函数，而在您提供了重载的构造函数的时候，C++编译器不会为您生成默认构造函数。 带默认值的构造函数参数就像函数可以有带默认值的参数一样，构造函数也可以。例如： 12345678910111213141516class Human &#123;private: string name; int age;public: //overloaded constructor (no default constructor) Human(string humansName, int humansAge = 25) &#123; name = humansName; age = humansAge; cout &lt;&lt; "Overloaded constructor creats:" &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; " of " &lt;&lt; age &lt;&lt; " years" &lt;&lt; endl; &#125; //... //other members&#125;; 注意默认构造函数是调用时可以不提供参数的构造函数，并不一定是不接受任何参数的构造函数，因此，下面的构造函数虽然有两个参数，但他们都有默认值，因此也是默认构造函数。 12345678910111213141516class Human &#123;private: string name; int age;public: //overloaded constructor (no default constructor) Human(string humansName="Adam", int humansAge = 25) &#123; name = humansName; age = humansAge; cout &lt;&lt; "Overloaded constructor creats:" &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; " of " &lt;&lt; age &lt;&lt; " years" &lt;&lt; endl; &#125; //... //other members&#125;; 因为实例化Human对象时仍可不提供任何参数 1Human adam;//Human takes default name "Adam" age 25 包含初始化列表的构造函数众所周知，构造函数对初始化成员变量很有用。另一种初始化成员变量的方法是使用初始化列表。 12345678910111213141516class Human &#123;private: string name; int age;public: //two parameters to initialize members age and name Human(string humansName, int humansAge) : name(humansName),age(humansAge) &#123; cout &lt;&lt; "Overloaded constructor creats:" &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; " of " &lt;&lt; age &lt;&lt; " years" &lt;&lt; endl; &#125; //... //other members&#125;;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++多态]]></title>
    <url>%2F2019%2F03%2F09%2FC-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态基础多态是面向对象语言的一种特征，让您能够以类似的方式处理不同类似的对象 为何需要多态行为1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class Fish &#123; public: void Swim() &#123; cout &lt;&lt; "Fish Swims" &lt;&lt; endl; &#125;&#125;;class Tuna :public Fish &#123; public: void Swim() &#123; cout &lt;&lt; "Tuna Swims" &lt;&lt; endl; &#125;&#125;;void MakeFishSwim(Fish&amp; inputFish) &#123; inputFish.Swim();&#125;int main() &#123; Tuna myDinner; myDinner.Swim(); MakeFishSwim(myDinner); return 0;&#125; 输出 Tuna swims! Fish swims! 虽然传入的Tuna对象，MakeFishSwim(Fish&amp;)也将其视为Fish,进而调用Fish::Swim。输出表明，虽然传入的是Tuna对象，但是得到的是Fish的输出。 使用虚函数实现多态行为（基类中多了virtual）123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Fish &#123;public: virtual void Swim() &#123; cout &lt;&lt; "Fish swims!" &lt;&lt; endl; &#125;&#125;;class Tuna :public Fish &#123;public: void Swim() &#123; cout &lt;&lt; "Tuna swims!" &lt;&lt; endl; &#125;&#125;;class Carp :public Fish &#123;public: void Swim() &#123; cout &lt;&lt; "Carp swims!" &lt;&lt; endl; &#125;;&#125;;void MakeFishSwim(Fish&amp; inputFish) &#123; inputFish.Swim();&#125;int main() &#123; Tuna myDinner; Carp myLunch; MakeFishSwim(myDinner); MakeFishSwim(myLunch); return 0;&#125; 输出 Tuna swims! Carp swims! 首先，根本没有调用Fish::Swim( ),因为存在覆盖版本的Tuna::Swim( )和Carp::Swim( ),它们优先于声明为虚函数的Fish::Swim( ) 这就是多态：将派生类视为基类对象，并执行派生类的Swim()实现 为何需要虚构造函数首先分析如下代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Fish &#123;public: Fish() &#123; cout &lt;&lt; "Constructed Fish" &lt;&lt; endl; &#125; ~Fish() &#123; cout &lt;&lt; "Destroyed Fish" &lt;&lt; endl; &#125;&#125;;class Tuna :public Fish &#123;public: Tuna() &#123; cout &lt;&lt; "Constructed Tuna" &lt;&lt; endl; &#125; ~Tuna() &#123; cout &lt;&lt; "Destructed Tuna" &lt;&lt; endl; &#125;&#125;;void DeleteFishMemory(Fish *pFish) &#123; delete pFish;&#125;int main() &#123; cout &lt;&lt; "Allocating a Tuna on the free store:" &lt;&lt; endl; Tuna* pTuna = new Tuna; cout &lt;&lt; "Deleting the Tuna:" &lt;&lt; endl; DeleteFishMemory(pTuna); cout &lt;&lt; "Instantiating a Tuna on the stack" &lt;&lt; endl; Tuna myDinner; cout &lt;&lt; "Automatic destruction as it goes out of scope" &lt;&lt; endl; return 0;&#125; 输出 Allocating a Tuna on the free store:Constructed FishConstructed TunaDeleting the Tuna:Destroyed FishInstantiating a Tuna on the stackConstructed FishConstructed TunaAutomatic destruction as it goes out of scopeDestructed TunaDestroyed Fish 注意到由于使用了关键字new，在自由存储区中构造了Tuna和Fish，但delete没有调用Tuna的析构函数，而只调用了Fish的析构函数；而构造和析构局部变量myDinner时，调用了基类和派生类的构造和析构过程。 这个程序表明，对于使用new在自由存储区中实例化的派生类对象，如果将其赋给基类指针，并通过该指针调用delete，将不会调用派生类的析构函数，这可能会导致资源未释放，内存泄漏等问题。必须引起重视！ 要避免这种问题，可将析构函数声明为虚函数。即： 1virtual ~Fish() &#123; cout&lt;&lt;"Destructed Fish"&lt;&lt;endl; &#125; 务必将基类的析构函数声明为虚函数 虚函数的工作原理——理解虚函数表参考虚拟表 抽象基类和纯虚函数不能实例化的基类被成为抽象基类，这样的基类只有一个用途，那就是从它派生出其他类。在C++中，要创建抽象基类，可声明纯虚函数。 1234class AbstractBase&#123;public: virtual void DoSomething()=0; &#125; 该声明告诉编译器，AbstractBase的派生类必须实现方法DoSomething（） 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Fish &#123;public: virtual void Swim() = 0;&#125;;class Tuna :public Fish &#123;public: void Swim() &#123; cout &lt;&lt; "Tuna swims fast in the sea!" &lt;&lt; endl; &#125;&#125;;class Carp :public Fish &#123; void Swim() &#123; cout &lt;&lt; "Carp swims slow in the lake!" &lt;&lt; endl; &#125;&#125;;void MakeFishSwim(Fish&amp; inputFish) &#123; inputFish.Swim();&#125;int main() &#123; Carp myLunch; Tuna myDinner; MakeFishSwim(myLunch); MakeFishSwim(myDinner); return 0;&#125; 输出 Carp swims slow in the lake!Tuna swims fast in the sea! 使用虚继承解决菱形问题分析如下代码 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class Animal &#123;public: Animal() &#123; cout &lt;&lt; "Animal constructor" &lt;&lt; endl; &#125; int age;&#125;;class Mammal :public Animal &#123;&#125;;class Bird :public Animal &#123;&#125;;class Reptail :public Animal &#123;&#125;;class Platypus :public Mammal, public Bird, public Reptail &#123;public: Platypus() &#123; cout &lt;&lt; "Platypus constructor" &lt;&lt; endl; &#125;&#125;;int main() &#123; Platypus duckBilledP; //unconmment next line to see compile failure //age is ambigous as there are thrre instances of base Animal //duckBilledP.age=25; return 0;&#125; 输出 Animal constructorAnimal constructorAnimal constructorPlatypus constructor 输出表明，由于采用了多继承，而且Platypus的全部三个基类都是从Animal类派生而来的，因此创建Platypus实例时，自动创建了三个Animal实例。如果您愿意，可以分别设置这三个属性： 123duckBilledP.Mammal::Animal::age=25;duckBilledP.Bird::Animal::age=25;duckBilledP.Reptile::Animal::age=25; 显然，鸭嘴兽应该只有一个age属性，但您希望Platypus类以共有方式继承Mammal/Bird/Reptile.解决方案是使用虚继承。如果派生类可能被用作基类，派生它最好使用关键字virtual 123456class Derived1: public virtual Base&#123; //...members and functions&#125;class Derived2: public virtual Base&#123; //...memebers and functions&#125; 如下列出了更佳的Platypus类声明 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Animal &#123;public: Animal() &#123; cout &lt;&lt; "Animal constructor" &lt;&lt; endl; &#125; int age;&#125;;class Mammal :public virtual Animal &#123;&#125;;class Bird :public virtual Animal &#123;&#125;;class Reptail :public virtual Animal &#123;&#125;;class Platypus final :public Mammal, public Bird, public Reptail &#123;public: Platypus() &#123; cout &lt;&lt; "Platypus constructor" &lt;&lt; endl; &#125;&#125;;int main() &#123; Platypus duckBilledP; //no compile error as there is only one Animal::age duckBilledP.age = 25; return 0;&#125; 输出 Animal constructorPlatypus constructor 如果将这里的输出与上面那个程序进行比较，会发现构造的Animal实例数减少到了1个，这表明之构造了一个Platypus。这是因为从Animalbb类派生Mammal/Bird/Reptile类时，使用了关键字virtual，这样Platypus继承这些类的时候，每个Platypus实例只包含一个Animal实例。另外，注意到使用了关键字final以禁止将Platypus类作基类。 注意C++关键字virtual的含义随上下文而异，对其含义总结如下: 在函数声明中，virtual意味着当基类指针指向派生类对象时，通过它可调用派生类的相应函数。 从Base类派生出Derrived1和Derrived2类时，如果使用了关键字virtual，则意味着再从Derived1和Derived2派生出Derived3时，每个Derived3实例只包含一个Base实例。 也就是说，关键字virtual被用于实现两个不同的概念。 表明覆盖意图限定符override前面的基类Fish都包含虚函数Swim()，如下面的代码所示： 123456class Fish &#123;public: virtual void Swim() &#123; cout &lt;&lt; "Fish swims" &lt;&lt; endl; &#125;&#125;; 假设派生类Tuna要定义函数Swim()，但特征标稍微不同——程序员本想覆盖Fish::Swim(),但不小心插入了关键字const ，如下所示: 123456class Tuna :public Fish &#123;public: void Swim() const &#123; cout &lt;&lt; "Tuna swims!" &lt;&lt; endl; &#125;&#125;; 在这种情况下，函数Tuna::Swim()实际上并不会覆盖Finish::Swim()，这是因为Tuna::Swim()包含const，导致它们的特征标不同。然而这些代码能通过编译，导致程序员误以为他在Tuna类中成狗的覆盖了函数的Swim()。从C++11起程序员可以使用限定符override来核实被覆盖的函数在基类中是否被声明为虚的： 123456class Tuna : public Fish &#123;public: void Swim() const override &#123; //！！！Error: no virtual fn with this sig in Fish cout &lt;&lt; "Tuna swims" &lt;&lt; endl; &#125;&#125;; 换而言之，override提供了一种强大的途径，让程序员能够明确表达对基类的虚函数u进行覆盖的意图，进而让编译器做如下检查： 基类函数是否是虚函数？ 基类中相应虚函数的特征标是否与派生类中被声明为override的函数完全相同？ 使用final来禁止覆盖函数被声明为final 的类不能用作基类，童谣，被声明为final的虚函数，不能再派生类中进行覆盖 1234567class Tuna:public Fish&#123;public: //override Fish::Swim and make this final void Swim() override final&#123; cout&lt;&lt;"Tuna swims!"&lt;&lt;endl; &#125; &#125; 您可以继承这个版本的Tuna类，但不能进一步覆盖函数Swim(): 1class BluefinTuna final:public Tuna&#123;public: void Swim()&#123;//Error: Swim() was final in Tuna, cannot override &#125;&#125; 我们声明BluefinTuna时，也使用了关键字final，这将禁止BluefinTunal类用作基类，因此下面的代码将导致错误： 1class FailedDerivation:public BluefinTuna&#123;&#125;; 可将复制构造函数声明为虚函数吗？？？从技术上说，C++不支持虚复制构造函数。但，如果能实现虚复制构造函数，则创建一个基类指针集合（如静态数组，其中的每个元素指向不同的派生类对象）：C++1234Fish * pFish[3];pFish[0]=new Tuna();pFish[1]=new Carp();pFish[2]=new Trout(); 并将其赋值给另一个相同类型的数组，虽然是通过Fish指针调用的复制构造函数，但复制指向的派生类对象，并将其进行深复制。 然而，这只是一个美好的梦想。 根本不可能实现虚复制构造函数，因为在基类方法声明中使用关键字virtual时，表示它将被派生类的实现覆盖，这种多态性是在运行阶段实现的。而构造函数只能创建固定类型的对象，不具备多态性，因此C++不允许使用虚复制构造函数。 虽然如此，但存在一种不错的解决方案，就是定义自己的克隆函数来实现上述目的： 1234567891011class Fish &#123;public: virtual Fish* Clone() const = 0;&#125;;class Tuna :public Fish &#123; //...other memeberspublic: Tuna* Clone() const &#123;//virtual clone function return new Tuna(*this);//return new Tuna that is copy of this &#125;&#125;; 虚函数Clone模拟了虚复制构造函数，但是需要显式使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;class Fish &#123;public: virtual Fish* Clone() = 0; virtual void Swim() = 0; virtual ~Fish() &#123;&#125;;&#125;;class Tuna :public Fish &#123;public: Fish* Clone()override &#123; return new Tuna(*this); &#125; void Swim()override final &#123; cout &lt;&lt; "Tuna swims fast in the sea" &lt;&lt; endl; &#125;&#125;;class BluefinTuna final : public Tuna &#123;public: Fish* Clone() override &#123; return new BluefinTuna(*this); &#125; //Cannot override Tuna::Swim as it is "final" in Tuna&#125;;class Carp final :public Fish &#123; Fish* Clone() override &#123; return new Carp(*this); &#125; void Swim() override final &#123; cout &lt;&lt; "Carp swims slow in the lake" &lt;&lt; endl; &#125;&#125;;int main() &#123; const int ARRAY_SIZE = 4; Fish* myFishes[ARRAY_SIZE] = &#123; NULL &#125;; myFishes[0] = new Tuna(); myFishes[1] = new Carp(); myFishes[2] = new BluefinTuna(); myFishes[3] = new Carp(); Fish* myNewFishes[ARRAY_SIZE]; for (int index = 0; index &lt; ARRAY_SIZE; ++index) &#123; myNewFishes[index] = myFishes[index]-&gt;Clone(); &#125; //invoke a virtual method to check for (int index = 0; index &lt; ARRAY_SIZE; ++index) &#123; myNewFishes[index]-&gt;Swim(); &#125; //memory cleanup for (int index = 0; index &lt; ARRAY_SIZE; ++index) &#123; delete myFishes[index]; delete myNewFishes[index]; &#125; return 0;&#125; 其他问题Q：抽象基类都不能被实例化，它有何用途呢？ 抽象基类并非为实例化而创建的，而近充当基类。它包含纯虚函数，指定了派生类必须实现哪些函数，可以充当接口 Q：抽象基类中，可以定义成员函数和成员属性吗？ 当然可以，但是这样的抽象基类也不能被实例化， 因为它至少包含一个纯虚函数，派生类必须实现该函数 Q: 在继承层次中，需要在所有虚函数声明中都是用关键字virtual，还是只需要在基类中这样做？ 只需要在基类的函数声明中使用关键字virtual即可 Q: 基类总应包含一个虚析构函数吗？ 最好如此。如果编写了如下代码; 123&gt; Base * pBase = new Derived();&gt; delete pBase;&gt; 则仅当析构函数~Base（）被声明为虚函数时，delete pBase才会调用析构函数~Derived（）。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的线性代数阅读笔记]]></title>
    <url>%2F2019%2F03%2F06%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[秩、逆矩阵、线性方程组——溯因推理正则矩阵（可逆矩阵、非奇异矩阵）不是正则矩阵的，我们称其为奇异矩阵线性方程组的解法 消元法 Gauss-Jordan法 逆矩阵的计算方法 利用初等行变换，使得（A| I ）→（ I |A^-1^） 初等变换 笔算的步骤可以总结为： 将某一行乘以c 将某一行的c倍加到另一行上去 交换两行 以上三种操作，都可以用“乘上某个矩阵”的形式表示出来（思考一下行操作与列操作） 从空间的角度思考可得： 将第i行乘以c，行列式的值为原来的c倍 将第j行乘以c加到第i行，行列式的值不变 交换第ij行，行列式的正负号改变 注意：当进行初等变换的时候，要么只进行初等行变换，要么只进行初等列变换，两者不能同时进行（PS从初等变换矩阵的角度去考虑） 核（零空间） 对于给定的A，在映射的作用下，满足Ax=O的x的集合称为A的核，记作Ker A 核又称作零空间 像（陪域） 对于给定的A，将x进行各种不同的变换，在A的作用下，y=Ax构成的集合，称为A的像 像又称作陪域 Ker A为原空间（定义域，即x所在的空间的一部分），Im A 为目标空间（值域，也就是y所在空间的一部分）维数 如果最多能取得n个线性无关的向量，则空间的维数是n 维数定理 对于m*n矩阵A，有dim Ker A + dim Im A = n，其中dim X表示X 的维数 线性子空间 对加法和数乘运算封闭的空间 线性无关、线性相关 如果对于数u~1~，u~2~，……，u~n~，当u~1~a~1~ + u~2~a~2~ + ……+ u~n~a~n~ = 0成立时，有u~1~ = u~2~ = ……= u~n~ ，则称a~1~ ，……，a~n~ 是线性无关的 A的各个列向量线性无关——不压缩 A的各个列向量线性相关——压缩 秩 Im A 的维数dim Im A就是矩阵A的秩 秩的基本性质 rank A≤min{m,n} 原因：目标空间是m维的，而包含其中的Im A无论如何也不可能让自己的维数超过m， 1原空间是n维，把空间全体都通过A映射过去，无论如何也不可能超过子集原来的维数n 在乘以可逆矩阵之后，维数不发生变化 对于一般的矩阵A，B 有： rank(BA)≤min{rank(A),rank(B)} 原因：第一阶段：原空间在A的作用下，移动到空间V上 1第二阶段：空间V在B的作用下，移动到空间W，所求即空间W的维数 通过第一阶段，空间V的维数已经变成了rankA，接下来无论B如何变化，最终的维数不会超过rankA，另外，在第二阶段中，就算空间全体都通过B进行了变换，最终为数也不会超过B，所以V作为空间的一部分，在B的作用下进行变化后，维数自然也不会超过rank B 转置矩阵的秩不变 逆矩阵存在的条件 是不是压缩扁平化，如果是，那么不存在其逆矩阵，否则存在逆矩阵 用空间的语言表达向量、矩阵和行列式三者的含义 向量有向线段（带有方向的线段）、空间内的点 矩阵空间到空间的映射 行列式上面的映射对应的“体积扩大率” 向量 最直接的定义——把数值罗列起来就是向量 强调分量的个数——N维向量 没有特别说明的情况下，我们说的向量就是列向量 相同维数的向量之间的加法 向量的数乘 空间 类似于二维向量（5,3）可以在二维平面上用一个点进行表示，三维向量也可以用三维空间中的一个点进行表示，像这样强调向量的位置的时候，也称为 位置向量 向量不仅可以用点进行表示，也可以用有向线段进行表示，这样加法就可以解释成线段的连接，数乘就可以解释为线段的伸缩 基底 线性空间（向量空间）——一个只用加法和数乘就能“运算”的世界（即对加法和数乘封闭） 如果有两个向量e1和e2不共线，有向量v：沿着e1走3步，沿着e2走两步，那么这组向量e1和e2就叫做基底，沿着各个基准向量走的步数就叫做坐标。e1和e2就称为基向量 线性组合 若任意向量x都可以用e1，e2……en的线性组合来表示，并且表示方法唯一，那么（e1，e2，……，en）称为基底 维数 维数=基向量的个数=坐标的分量数 矩阵 暂时的定义： 把数排列成长方形就是矩阵 方阵：行数和列数相同 相同规模（行数列数都相等，即同型矩阵）的矩阵之间可以进行加法 矩阵的数乘 矩阵相乘 矩阵与向量的乘积是向量 矩阵的列数（宽度）为“输入”的向量维数，行数（高度）为“输出”的向量维数 计算的时候，就好比把输入的列向量放倒（开车！？）然后将对应的元素分别相乘 矩阵就是一种表示平直关系（函数关系）的便利手段 由于aij可以理解为“自变量j对结果i所施加的影响”，这样理解的话，自变量对因变量整体的影响表现出来就是矩阵 矩阵就是映射 矩阵确定了从一个向量到另外一个向量的映射 映射相同则矩阵相同 矩阵的乘积 将右边的矩阵按列分割开来，将每一列看做一个列向量 将分割开的列向量与左边的矩阵做乘法（矩阵与向量的乘法） 把所得的结果拼接起来 行向量在左边，列向量在右边 矩阵的乘方 矩阵的乘方相当于映射的迭代 例如：A^3^ 表示先A再A再次A的操作，A^n^ 表示反复n次的操作 注意：矩阵没有平方和公式。（AB）^2^ 有时候不等于A^2^B^2^ A^0^=I 零矩阵、单位矩阵、对角矩阵 零矩阵： 所有元素都是0的矩阵称为 零矩阵 ， 在A≠O，B≠O的情况下，也有可能得到BA=O 就算A≠O，也有可能得到A^2^=O 单位矩阵 从左上到右下方向的对角元素是1，其余全部是0的矩阵称为单位矩阵 单位矩阵表示什么都不做的映射 对角矩阵 从左上到右下的对角线上的值称为对角元素，其他元素称为非对角元素，当非对角元素全部为0时，该矩阵称为对角矩阵 对角矩阵表示的映射是沿着坐标轴伸缩，其中对角元素就是各轴伸缩的倍率 逆矩阵 逆矩阵=逆映射 可以理解为每个方向“反其道而行之” 分块矩阵 分块矩阵的加法 类似于矩阵的加法 分块矩阵的数乘 类似于矩阵的数乘 分块矩阵的乘法 可以在分块以后把各个“大元素”当做数值，直接套用普通的矩阵运算法则 分块对角矩阵 对角区块的概念 分块对角矩阵的好处在于，我们可以将整个映射看作是由多个独立的变换组成的，其中每个变换对应一个区块 分块对角矩阵的乘方类似于矩阵的乘方 分块对角矩阵的乘方类似于对角矩阵的乘方 坐标变换 坐标变换可以用“乘以方阵A”的形式进行表示，这里的A存在逆矩阵 乘以某个存在逆矩阵的方阵A，也可以用坐标变换来表示 转置矩阵 共轭转置 矩阵转置以后所有的复数都写成其共轭复数 应当时刻注意矩阵的规模（大小、行数、列数）行列式=体积扩大率 一般情况下，对于n阶方阵A，“n维版本的体积的扩大率”，就是行列式 图形扁平化的情况下，体积扩大率为0 对图形进行镜像反转变换的情况下， 可以用负的扩大率来表示 行列式的性质 简单性质 |AB|=|A|*|B| 意义： 首先映射B造成了det B倍的变换，接下来映射A带来了det A倍的变化，于是先B后A自然就造成了体积扩大det A*det B倍 转置矩阵的行列式与原行列式相等 行列互换以后，行列式的所有性质依然成立 关键性质 多重线性 相当于可以把行列式中的因子提出来，集合上可以理解为一叠扑克牌，它的高变为原来的10倍，相当于体积变成原来的10倍 根据多重线性性质，n阶矩阵A乘以常数c以后，所得矩阵的行列式是原来矩阵A行列式的c^n^ 倍，注意不是c倍 交替性 交换行列式中的两行或者两列时，体积保持不变（行列式的绝对值不变），行列式正负不变 行列式的计算方法——笔算法（高斯消去法） 行列式按行（列）展开与逆矩阵]]></content>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客搭建]]></title>
    <url>%2F2019%2F03%2F05%2FHexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[HEXO博客搭建教程博客搭建准备环境 Node.js 下载，并安装。详细步骤：https://www.simon96.online/2018/11/10/hexo-env/ Git 下载，并安装。详细步骤：https://www.simon96.online/2018/11/10/hexo-env/ 安装Hexo，在命令行（即Git Bash）运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： 以下，即存放Hexo初始化文件的路径， 即站点目录。 1$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，在路径下，会产生这些文件和文件夹： 1.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 路径为&lt;folder&gt;\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 路径为&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 浏览器访问网址： http://localhost:4000/ 至此，您的Hexo博客已经搭建在本地。 实施方案方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 1$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 1$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为&lt;Github账号名称&gt;.github.io； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 1$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 1# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 1$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为&lt;Github账号名称&gt;.coding.me； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 主题优化选择主题Hexo默认的主题是landscape，推荐以下主题： snippet Hiero JSimple BlueLake 详见：https://github.com/search?q=hexo-theme 应用主题 下载主题 将下载好的主题文件夹，粘贴到站点目录的themes下。 更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称： 1# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt; 主题优化以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。 主题优化一般包括： 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 问题：引用国外字体镜像较慢。 解决：可以改用国内的。将\themes*\layout_partials\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 主题优化还包括： 添加背景图在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1body&#123; background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 修改Logo字体在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1@font-face &#123; font-family: Zitiming; src: url(&apos;/fonts/Zitiming.ttf&apos;);&#125;.site-title &#123; font-size: 40px !important; font-family: &apos;Zitiming&apos; !important;&#125; 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 Zitiming.ttf ，具体字库自己从网上下载即可。 修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量： 1// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 网站标题栏背景颜色打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1.site-meta &#123; background: $blue; //修改为自己喜欢的颜色&#125; 自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 文章加密访问打开 themes/*/layout/_partials/head.swig文件,在 之前插入代码： 1&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 写文章时加上password: *： 1---title: 2018date: 2018-10-25 16:10:03password: 123456--- 实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\*\layout\_layout.swig文件末尾添加： 1&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 静态资源压缩在站点目录下： 1$ npm install gulp -g 安装gulp插件： 1npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 1var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 1hexo ggulphexo d 修改访问URL路径默认情况下访问URL路径为：domain/2018/10/18/关于本站,修改为 domain/About/关于本站。 编辑 Hexo 站点下的 _config.yml 文件，修改其中的 permalink字段： 1permalink: :category/:title/ 博文置顶 安装插件 $ npm uninstall hexo-generator-index –save$ npm install hexo-generator-index-pin-top –save 然后在需要置顶的文章的Front-matter中加上top即可： 1---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志 打开：/themes/*/layout/_macro/post.swig，定位到 ，插入以下代码即可： 1&#123;% if post.top %&#125; 置顶 |&#123;% endif %&#125; 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 1// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 1# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 创建分类页在终端窗口下，定位到 Hexo 站点目录下，新建： 1$ cd &lt;站点目录&gt;$ hexo new page categories 加入 广告主要有两种：百度SSP和谷歌Adsense。方法类似： 注册，复制广告代码 部署到网站。 2.1. 新建 theme/*/layout/_custom/google_ad.swig，将 AdSense 上的代码粘贴进去 2.2. 头部。在 theme/*/layout/_custom/head.swig 中也粘贴一份 2.3. 每篇博客。在 theme/*/layout/post.swig 里中在希望看到的地方加上： 1&#123;% include &apos;_custom/google_ad.swig&apos; %&#125; 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 12345&#123;% block content %&#125; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_ad.swig&apos; %&#125; &#123;% endblock %&#125; 等待审核通过。如果失败，可再次申请。 添加萌萌哒 安装插件 1npm install --save hexo-helper-live2d 复制你喜欢的模型名字： Epsilon2.1 Gantzert_Felixander haru miku ni-j nico nietzche nipsilon nito shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 1live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true 建配置文件 4.1. 在站点目录下建文件夹live2d_models， 4.2. 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 4.3. 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可： npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt; 在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 插件配置以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。 评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 Valine1.1. 获取APP ID 和 APP Key 请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用， 进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 1.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 1.3. 运行hexo g&amp;&amp;hexo d推送到博客。 来必力/livere2.1. 登陆 来必力 获取你的 LiveRe UID。 2.2. 填写LiveRe UID到主题配置文件_config.yml 畅言3.1.获取APP ID 和 APP Key 请先登录或注册 畅言, 点击“立即免费获取畅言”， 新建站点，点击管理，点击评论插件&gt;评论管理， 点击后台总览，然后就能看到你的APP ID和APP Key了。 3.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 3.3. 运行hexo g&amp;&amp;hexo d推送到博客。 gitment4.1. 安装插件： npm i –save gitment 4.2. 申请应用 在New OAuth App为你的博客应用一个密钥: 1Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址 4.3. 配置 编辑主题配置文件themes/*/_config.yml: 1# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 公开的git仓库,评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_pro Disqus编辑 主题配置文件themes/*/_config.yml， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。 1disqus: enable: false shortname: count: true 数据统计与分析 推荐指数 优点 缺点 不蒜子 4 可直接将访问次数显示在您在网页上（也可不显示） 只计数 百度统计 3 收录慢 不蒜子编辑 主题配置文件 themes/*/_config.yml中的busuanzi_count的配置项即可。 当enable: true时，代表开启全局开关。 若site_uv（本站访客数）、site_pv（本站访客数）、page_pv（本文总阅读量）的值均为false时，不蒜子仅作记录而不会在页面上显示。 注意： 1不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！ 解决办法： 找到主题调用不蒜子的swig文件。一般在”\themes*\layout_third-party\analytics\busuanzi-counter.swig” 更改域名 1把原有的：&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 百度统计 登录 百度统计，定位到站点的代码获取页面 复制统计脚本 id，如图：​ 编辑 主题配置文件themes/*/_config.yml，修改字段 google_analytics，值设置成你的统计脚本 id。 内容分享服务 推荐指数 优点 缺点 百度分享 4 稳定 不太美观 need-more-share2 4 美观 更新不及时（比如微信分享API） 百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true即可。 1# 百度分享服务baidushare: true need-more-share2编辑 主题配置文件，添加/修改字段 needmoreshare2，值为 true即可。 1needmoreshare2: enable: true 搜索服务 推荐指数 优点 缺点 Local Search 4 配置方便 Swiftype 2 需注册 Algolia 2 需注册 Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 1search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 1# Local searchlocal_search: enable: true 错误分析如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。 YAML Parsing Error1JS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29: last_updated: Last updated: %s 参数中包含冒号，请用加引号，如Last updated: %s 1JS-YAML: bad indentation of a mapping entry at line 18, column 31: last_updated：&quot;Last updated: %s&quot; 字段后面的冒号必须为英文冒号，如：last_updated: 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s” EMFILE Error1Error: EMFILE, too many open files 生成大量的文件时，可能遇到EMFILE错误。 可以运行以下命令来增加允许同步I / O操作的数量。 1$ ulimit -n 10000 Process Out of Memory当hexo g时，遇到以下错误： 1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory 如下，更改hexo-cli文件的第一行，来增大nodejs堆内存.该bug已在新版本修复。 1#!/usr/bin/env node --max_old_space_size=8192 Git Deployment Problems RPC failed 1error: RPC failed; result=22, HTTP code = 403fatal: &apos;username.github.io&apos; does not appear to be a git repository 确保你有你的电脑上设置git正确或尝试使用HTTPS存储库URL。 Error: ENOENT: no such file or directory 这个需要有一定的git的知识，因为可能是由于写错了标签,类别,或文件名，导致本地和github冲突了，Git不能自动合并这一变化所以它打破了自动分支。 解决办法： 检查文章的标签和类别,确保本地和github上是相同的。 合并分支（Commit）。 清除，重构。在站点目录下，命令行（即Git Bash）运行hexo clean和hexo g 手动将站点目录下的public文件夹复制到您的桌面 从你的master分支切换到部署在本地分支。 从桌面复制public文件夹到本地分支。 合并分支到github（Commit）。 切回master分支。 Server Problems1Error: listen EADDRINUSE 你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置： 1$ hexo server -p 5000 Plugin Installation Problems1npm ERR! node-waf configure build 这个错误可能发生在试图安装一个用Cc++或另一个javascript语言编写的插件。确保您已经安装了正确的编译器在您的计算机上。 Error with DTrace (Mac OS X)1&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; DTrace安装可能有问题，重装: 1$ npm install hexo --no-optional 详见 #1326 Iterate Data Model on Jade or SwigHexo使用仓库的数据模型。这不是一个数组,所以你可能需要将对象转换为iterable。 1&#123;% for post in site.posts.toArray() %&#125;&#123;% endfor %&#125; Data Not Updated一些数据不能更新或新生成的文件的最后一个版本完全相同。清理缓存，再试一次： 1$ hexo clean No command is executed那个不能使用除help、init和version以外的命令行（即Git Bash）时, 有可能时站点目录下的 package.json文件，缺少hexo，如下: 1&#123; &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;&#125; Escape ContentsHexo使用Nunjucks渲染的页面. { { } }或{ % % }将解析和可能会引起麻烦， 如果要在博文中出现，必须使用三引号： 12 Hello 12 ENOSPC Error (Linux)如果运行命令$ hexo server 返回一个错误: 1Error: watch ENOSPC … 可以通过运行$ npm dedupe或者以下命令行（即Git Bash）： 1$ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 来增加测试时，你可以看见的文件数量。 EMPERM Error (Windows Subsystem for Linux)如果在Windows Subsystem for Linux，运行命令$ hexo server 返回这个错误: 1Error: watch /path/to/hexo/theme/ EMPERM 因为目前在Windows Subsystem for Linux中，有些内容更改时，还不能实时更新到hexo服务器。 所以需要重新编译，再启动服务器： 1$ hexo generate$ hexo server -s Template render error有时运行命令$ hexo generate 返回一个错误: 1FATAL Something’s wrong. Maybe you can find the solution here: &lt;http://hexo.io/docs/troubleshooting.html&gt;Template render error: (unknown path) 这意味着有些认不出来单词在你的文件，并且很可能在你的新博文,或者配置文件_config.yml中，比如缩进错误： 错误例子： 1plugins:hexo-generator-feedhexo-generator-sitemap\ 常用操作创建文章命令： 1$ hexo new [layout] &lt;title&gt; 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 1$ hexo publish [layout] &lt;title&gt; title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址]]></content>
  </entry>
  <entry>
    <title><![CDATA[第二周计划与总结]]></title>
    <url>%2F2019%2F03%2F03%2F%E7%AC%AC%E4%BA%8C%E5%91%A8%E8%AE%A1%E5%88%92%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第二周计划与总结英语六级 Word List 5 Word List 6 Word List 7 Word List 8 C++ 类 IO库 顺序容器 泛型算法 关联容器 回顾 离散数学 离散数学及其应用 高等数学 8.3 8.4 8.5 8.6 Hexo博客搭建 Hexo博客搭建 总结与反思 这一周的状态还是不错的，C++的一些内容没有完成，（不过说实在的，C++的任务好像有些多了。） 感觉大学物理好难啊。需要下来好好看看。 要看《离散数学及其应用》了! 留给英语背单词的时间不是很多。下周要平衡一下。]]></content>
      <tags>
        <tag>大一下计划于总结</tag>
      </tags>
  </entry>
</search>
